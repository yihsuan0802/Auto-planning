import * as Highcharts from 'highcharts';
import { chart, mapChart, stockChart } from 'highcharts';
import { AsyncSubject } from 'rxjs';
import { Directive, ElementRef, Input, InjectionToken, Injectable, Inject, NgModule } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/chart.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as ɵngcc0 from '@angular/core';
class Chart {
    /**
     * @param {?=} options
     */
    constructor(options = { series: [] }) {
        this.options = options;
        this.refSubject = new AsyncSubject();
        this.ref$ = this.refSubject.asObservable();
    }
    /**
     * Add Point
     * @param {?} point         Highcharts.DataPoint, number touple or number
     * @param {?=} serieIndex    Index position of series. This defaults to 0.
     * @param {?=} redraw        Flag whether or not to redraw point. This defaults to true.
     * @param {?=} shift         Shift point to the start of series. This defaults to false.
     * @return {?}
     */
    addPoint(point, serieIndex = 0, redraw = true, shift = false) {
        this.ref$.subscribe((/**
         * @param {?} chart
         * @return {?}
         */
        chart => {
            if (chart.series.length > serieIndex) {
                chart.series[serieIndex].addPoint(point, redraw, shift);
            }
        }));
    }
    /**
     * Add Series
     * @param {?} series        Series Configuration
     * @param {?=} redraw        Flag whether or not to redraw series. This defaults to true.
     * @param {?=} animation     Whether to apply animation, and optionally animation configuration. This defaults to false.
     * @return {?}
     */
    addSeries(series, redraw = true, animation) {
        this.ref$.subscribe((/**
         * @param {?} chart
         * @return {?}
         */
        chart => {
            chart.addSeries(series, redraw, animation);
        }));
    }
    /**
     * Remove Point
     * @param {?} pointIndex    Index of Point
     * @param {?=} serieIndex    Specified Index of Series. Defaults to 0.
     * @return {?}
     */
    removePoint(pointIndex, serieIndex = 0) {
        this.ref$.subscribe((/**
         * @param {?} chart
         * @return {?}
         */
        chart => {
            if (chart.series.length > serieIndex && chart.series[serieIndex].data.length > pointIndex) {
                chart.series[serieIndex].removePoint(pointIndex, true);
            }
        }));
    }
    /**
     * Remove Series
     * @param {?} seriesIndex    Index position of series to remove.
     * @return {?}
     */
    removeSeries(seriesIndex) {
        this.ref$.subscribe((/**
         * @param {?} chart
         * @return {?}
         */
        chart => {
            if (chart.series.length > seriesIndex) {
                chart.series[seriesIndex].remove(true);
            }
        }));
    }
    /**
     * @param {?} el
     * @return {?}
     */
    init(el) {
        if (!this.ref) {
            chart(el.nativeElement, this.options, (/**
             * @param {?} chart
             * @return {?}
             */
            chart => {
                if (!this.ref) { // TODO: workaround for doubled callbacks on exporting charts: issue #238
                    this.refSubject.next(chart);
                    this.ref = chart;
                    this.refSubject.complete();
                }
            }));
        }
    }
    /**
     * @return {?}
     */
    destroy() {
        if (this.ref) {
            this.options = this.ref.options;
            this.ref.destroy();
            this.ref = undefined;
            // new init subject
            this.refSubject = new AsyncSubject();
            this.ref$ = this.refSubject.asObservable();
        }
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    Chart.prototype.refSubject;
    /** @type {?} */
    Chart.prototype.ref$;
    /** @type {?} */
    Chart.prototype.ref;
    /**
     * @type {?}
     * @private
     */
    Chart.prototype.options;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/mapchart.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Felix Itzenplitz. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at
 * https://github.com/cebor/angular-highcharts/blob/master/LICENSE
 */
class MapChart {
    /**
     * @param {?=} options
     */
    constructor(options = { series: [] }) {
        this.options = options;
        this.refSubject = new AsyncSubject();
        this.ref$ = this.refSubject.asObservable();
    }
    /**
     * @param {?} el
     * @return {?}
     */
    init(el) {
        if (!this.ref) {
            mapChart(el.nativeElement, this.options, (/**
             * @param {?} chart
             * @return {?}
             */
            chart => {
                this.refSubject.next(chart);
                this.ref = chart;
                this.refSubject.complete();
            }));
        }
    }
    /**
     * @return {?}
     */
    destroy() {
        if (this.ref) {
            this.options = this.ref.options;
            this.ref.destroy();
            this.ref = undefined;
            // new init subject
            this.refSubject = new AsyncSubject();
            this.ref$ = this.refSubject.asObservable();
        }
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    MapChart.prototype.refSubject;
    /** @type {?} */
    MapChart.prototype.ref$;
    /** @type {?} */
    MapChart.prototype.ref;
    /**
     * @type {?}
     * @private
     */
    MapChart.prototype.options;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/stockchart.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Felix Itzenplitz. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at
 * https://github.com/cebor/angular-highcharts/blob/master/LICENSE
 *
 * @author Felix Itzenplitz
 * @author Timothy A. Perez (contributor)
 */
class StockChart {
    /**
     * @param {?=} options
     */
    constructor(options = { series: [] }) {
        this.options = options;
        this.refSubject = new AsyncSubject();
        this.ref$ = this.refSubject.asObservable();
    }
    /**
     * @param {?} el
     * @return {?}
     */
    init(el) {
        if (!this.ref) {
            stockChart(el.nativeElement, this.options, (/**
             * @param {?} chart
             * @return {?}
             */
            chart => {
                this.refSubject.next(chart);
                this.ref = chart;
                this.refSubject.complete();
            }));
        }
    }
    /**
     * @return {?}
     */
    destroy() {
        if (this.ref) {
            this.options = this.ref.options;
            this.ref.destroy();
            this.ref = undefined;
            // new init subject
            this.refSubject = new AsyncSubject();
            this.ref$ = this.refSubject.asObservable();
        }
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    StockChart.prototype.refSubject;
    /** @type {?} */
    StockChart.prototype.ref$;
    /** @type {?} */
    StockChart.prototype.ref;
    /**
     * @type {?}
     * @private
     */
    StockChart.prototype.options;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/chart.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ChartDirective {
    /**
     * @param {?} el
     */
    constructor(el) {
        this.el = el;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (!changes.chart.isFirstChange()) {
            this.destroy();
            this.init();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.init();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy();
    }
    /**
     * @private
     * @return {?}
     */
    init() {
        if (this.chart instanceof Chart || this.chart instanceof StockChart || this.chart instanceof MapChart) {
            this.chart.init(this.el);
        }
    }
    /**
     * @private
     * @return {?}
     */
    destroy() {
        if (this.chart instanceof Chart || this.chart instanceof StockChart || this.chart instanceof MapChart) {
            this.chart.destroy();
        }
    }
}
ChartDirective.ɵfac = function ChartDirective_Factory(t) { return new (t || ChartDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ChartDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ChartDirective, selectors: [["", "chart", ""]], inputs: { chart: "chart" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
ChartDirective.ctorParameters = () => [
    { type: ElementRef }
];
ChartDirective.propDecorators = {
    chart: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ChartDirective, [{
        type: Directive,
        args: [{
                selector: '[chart]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { chart: [{
            type: Input
        }] }); })();
if (false) {
    /** @type {?} */
    ChartDirective.prototype.chart;
    /**
     * @type {?}
     * @private
     */
    ChartDirective.prototype.el;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/chart.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let HIGHCHARTS_MODULES = new InjectionToken('HighchartsModules');
class ChartService {
    /**
     * @param {?} chartModules
     */
    constructor(chartModules) {
        this.chartModules = chartModules;
    }
    /**
     * @return {?}
     */
    initModules() {
        this.chartModules.forEach((/**
         * @param {?} chartModule
         * @return {?}
         */
        chartModule => {
            chartModule(Highcharts);
        }));
    }
}
ChartService.ɵfac = function ChartService_Factory(t) { return new (t || ChartService)(ɵngcc0.ɵɵinject(HIGHCHARTS_MODULES)); };
ChartService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ChartService, factory: ChartService.ɵfac });
/** @nocollapse */
ChartService.ctorParameters = () => [
    { type: Array, decorators: [{ type: Inject, args: [HIGHCHARTS_MODULES,] }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ChartService, [{
        type: Injectable
    }], function () { return [{ type: Array, decorators: [{
                type: Inject,
                args: [HIGHCHARTS_MODULES]
            }] }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    ChartService.prototype.chartModules;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/chart.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0 = [];
class ChartModule {
    /**
     * @param {?} cs
     */
    constructor(cs) {
        this.cs = cs;
        this.cs.initModules();
    }
}
ChartModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ChartModule });
ChartModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ChartModule_Factory(t) { return new (t || ChartModule)(ɵngcc0.ɵɵinject(ChartService)); }, providers: [
        { provide: HIGHCHARTS_MODULES, useValue: ɵ0 },
        ChartService
    ] });
/** @nocollapse */
ChartModule.ctorParameters = () => [
    { type: ChartService }
];
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ChartModule, { declarations: [ChartDirective], exports: [ChartDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ChartModule, [{
        type: NgModule,
        args: [{
                exports: [ChartDirective],
                declarations: [ChartDirective],
                providers: [
                    { provide: HIGHCHARTS_MODULES, useValue: ɵ0 },
                    ChartService
                ]
            }]
    }], function () { return [{ type: ChartService }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    ChartModule.prototype.cs;
}

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: angular-highcharts.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { Chart, ChartDirective, ChartModule, HIGHCHARTS_MODULES, MapChart, StockChart, ChartService as ɵa };

//# sourceMappingURL=angular-highcharts.js.map