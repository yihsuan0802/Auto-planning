/**
 * @fileoverview added by tsickle
 * Generated from: lib/chart.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as Highcharts from 'highcharts';
import { AsyncSubject } from 'rxjs';
export class Chart {
    /**
     * @param {?=} options
     */
    constructor(options = { series: [] }) {
        this.options = options;
        this.refSubject = new AsyncSubject();
        this.ref$ = this.refSubject.asObservable();
    }
    /**
     * Add Point
     * @param {?} point         Highcharts.DataPoint, number touple or number
     * @param {?=} serieIndex    Index position of series. This defaults to 0.
     * @param {?=} redraw        Flag whether or not to redraw point. This defaults to true.
     * @param {?=} shift         Shift point to the start of series. This defaults to false.
     * @return {?}
     */
    addPoint(point, serieIndex = 0, redraw = true, shift = false) {
        this.ref$.subscribe((/**
         * @param {?} chart
         * @return {?}
         */
        chart => {
            if (chart.series.length > serieIndex) {
                chart.series[serieIndex].addPoint(point, redraw, shift);
            }
        }));
    }
    /**
     * Add Series
     * @param {?} series        Series Configuration
     * @param {?=} redraw        Flag whether or not to redraw series. This defaults to true.
     * @param {?=} animation     Whether to apply animation, and optionally animation configuration. This defaults to false.
     * @return {?}
     */
    addSeries(series, redraw = true, animation) {
        this.ref$.subscribe((/**
         * @param {?} chart
         * @return {?}
         */
        chart => {
            chart.addSeries(series, redraw, animation);
        }));
    }
    /**
     * Remove Point
     * @param {?} pointIndex    Index of Point
     * @param {?=} serieIndex    Specified Index of Series. Defaults to 0.
     * @return {?}
     */
    removePoint(pointIndex, serieIndex = 0) {
        this.ref$.subscribe((/**
         * @param {?} chart
         * @return {?}
         */
        chart => {
            if (chart.series.length > serieIndex && chart.series[serieIndex].data.length > pointIndex) {
                chart.series[serieIndex].removePoint(pointIndex, true);
            }
        }));
    }
    /**
     * Remove Series
     * @param {?} seriesIndex    Index position of series to remove.
     * @return {?}
     */
    removeSeries(seriesIndex) {
        this.ref$.subscribe((/**
         * @param {?} chart
         * @return {?}
         */
        chart => {
            if (chart.series.length > seriesIndex) {
                chart.series[seriesIndex].remove(true);
            }
        }));
    }
    /**
     * @param {?} el
     * @return {?}
     */
    init(el) {
        if (!this.ref) {
            Highcharts.chart(el.nativeElement, this.options, (/**
             * @param {?} chart
             * @return {?}
             */
            chart => {
                if (!this.ref) { // TODO: workaround for doubled callbacks on exporting charts: issue #238
                    this.refSubject.next(chart);
                    this.ref = chart;
                    this.refSubject.complete();
                }
            }));
        }
    }
    /**
     * @return {?}
     */
    destroy() {
        if (this.ref) {
            this.options = this.ref.options;
            this.ref.destroy();
            this.ref = undefined;
            // new init subject
            this.refSubject = new AsyncSubject();
            this.ref$ = this.refSubject.asObservable();
        }
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    Chart.prototype.refSubject;
    /** @type {?} */
    Chart.prototype.ref$;
    /** @type {?} */
    Chart.prototype.ref;
    /**
     * @type {?}
     * @private
     */
    Chart.prototype.options;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hhcnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9hbmd1bGFyLWhpZ2hjaGFydHMvIiwic291cmNlcyI6WyJsaWIvY2hhcnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFDQSxPQUFPLEtBQUssVUFBVSxNQUFNLFlBQVksQ0FBQztBQUN6QyxPQUFPLEVBQUUsWUFBWSxFQUFjLE1BQU0sTUFBTSxDQUFDO0FBY2hELE1BQU0sT0FBTyxLQUFLOzs7O0lBS2hCLFlBQW9CLFVBQThCLEVBQUUsTUFBTSxFQUFFLEVBQUUsRUFBRTtRQUE1QyxZQUFPLEdBQVAsT0FBTyxDQUFxQztRQUp4RCxlQUFVLEdBQW1DLElBQUksWUFBWSxFQUFFLENBQUM7UUFDeEUsU0FBSSxHQUFpQyxJQUFJLENBQUMsVUFBVSxDQUFDLFlBQVksRUFBRSxDQUFDO0lBR0QsQ0FBQzs7Ozs7Ozs7O0lBU3BFLFFBQVEsQ0FBQyxLQUFZLEVBQUUsYUFBcUIsQ0FBQyxFQUFFLFNBQWtCLElBQUksRUFBRSxRQUFpQixLQUFLO1FBQzNGLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUzs7OztRQUFDLEtBQUssQ0FBQyxFQUFFO1lBQzFCLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsVUFBVSxFQUFFO2dCQUNwQyxLQUFLLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO2FBQ3pEO1FBQ0gsQ0FBQyxFQUFDLENBQUM7SUFDTCxDQUFDOzs7Ozs7OztJQVFELFNBQVMsQ0FBQyxNQUFvQyxFQUFFLE1BQU0sR0FBRyxJQUFJLEVBQUUsU0FBa0I7UUFDL0UsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTOzs7O1FBQUMsS0FBSyxDQUFDLEVBQUU7WUFDMUIsS0FBSyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUUsTUFBTSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBQzdDLENBQUMsRUFBQyxDQUFDO0lBQ0wsQ0FBQzs7Ozs7OztJQU9ELFdBQVcsQ0FBQyxVQUFrQixFQUFFLFVBQVUsR0FBRyxDQUFDO1FBQzVDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUzs7OztRQUFDLEtBQUssQ0FBQyxFQUFFO1lBQzFCLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsVUFBVSxJQUFJLEtBQUssQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxVQUFVLEVBQUU7Z0JBQ3pGLEtBQUssQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsV0FBVyxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsQ0FBQzthQUN4RDtRQUNILENBQUMsRUFBQyxDQUFDO0lBQ0wsQ0FBQzs7Ozs7O0lBTUQsWUFBWSxDQUFDLFdBQW1CO1FBQzlCLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUzs7OztRQUFDLEtBQUssQ0FBQyxFQUFFO1lBQzFCLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsV0FBVyxFQUFFO2dCQUNyQyxLQUFLLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUN4QztRQUNILENBQUMsRUFBQyxDQUFDO0lBQ0wsQ0FBQzs7Ozs7SUFFRCxJQUFJLENBQUMsRUFBYztRQUNqQixJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRTtZQUNiLFVBQVUsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLGFBQWEsRUFBRSxJQUFJLENBQUMsT0FBTzs7OztZQUFFLEtBQUssQ0FBQyxFQUFFO2dCQUN2RCxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxFQUFFLHlFQUF5RTtvQkFDeEYsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBQzVCLElBQUksQ0FBQyxHQUFHLEdBQUcsS0FBSyxDQUFDO29CQUNqQixJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsRUFBRSxDQUFDO2lCQUM1QjtZQUNILENBQUMsRUFBQyxDQUFDO1NBQ0o7SUFDSCxDQUFDOzs7O0lBRUQsT0FBTztRQUNMLElBQUksSUFBSSxDQUFDLEdBQUcsRUFBRTtZQUNaLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUM7WUFDaEMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUNuQixJQUFJLENBQUMsR0FBRyxHQUFHLFNBQVMsQ0FBQztZQUVyQixtQkFBbUI7WUFDbkIsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO1lBQ3JDLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxZQUFZLEVBQUUsQ0FBQztTQUM1QztJQUNILENBQUM7Q0FDRjs7Ozs7O0lBakZDLDJCQUF3RTs7SUFDeEUscUJBQW9FOztJQUNwRSxvQkFBc0I7Ozs7O0lBRVYsd0JBQW9EIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRWxlbWVudFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0ICogYXMgSGlnaGNoYXJ0cyBmcm9tICdoaWdoY2hhcnRzJztcbmltcG9ydCB7IEFzeW5jU3ViamVjdCwgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgRmVsaXggSXR6ZW5wbGl0ei4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdFxuICogaHR0cHM6Ly9naXRodWIuY29tL2NlYm9yL2FuZ3VsYXItaGlnaGNoYXJ0cy9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKiBAYXV0aG9yIEZlbGl4IEl0emVucGxpdHpcbiAqIEBhdXRob3IgVGltb3RoeSBBLiBQZXJleiAoY29udHJpYnV0b3IpXG4gKi9cbmV4cG9ydCB0eXBlIFBvaW50ID0gbnVtYmVyIHwgW251bWJlciwgbnVtYmVyXSB8IEhpZ2hjaGFydHMuUG9pbnQ7XG5cbmV4cG9ydCBjbGFzcyBDaGFydCB7XG4gIHByaXZhdGUgcmVmU3ViamVjdDogQXN5bmNTdWJqZWN0PEhpZ2hjaGFydHMuQ2hhcnQ+ID0gbmV3IEFzeW5jU3ViamVjdCgpO1xuICByZWYkOiBPYnNlcnZhYmxlPEhpZ2hjaGFydHMuQ2hhcnQ+ID0gdGhpcy5yZWZTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICByZWY6IEhpZ2hjaGFydHMuQ2hhcnQ7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBvcHRpb25zOiBIaWdoY2hhcnRzLk9wdGlvbnMgPSB7IHNlcmllczogW10gfSkge31cblxuICAvKipcbiAgICogQWRkIFBvaW50XG4gICAqIEBwYXJhbSBwb2ludCAgICAgICAgIEhpZ2hjaGFydHMuRGF0YVBvaW50LCBudW1iZXIgdG91cGxlIG9yIG51bWJlclxuICAgKiBAcGFyYW0gc2VyaWVJbmRleCAgICBJbmRleCBwb3NpdGlvbiBvZiBzZXJpZXMuIFRoaXMgZGVmYXVsdHMgdG8gMC5cbiAgICogQHBhcmFtIHJlZHJhdyAgICAgICAgRmxhZyB3aGV0aGVyIG9yIG5vdCB0byByZWRyYXcgcG9pbnQuIFRoaXMgZGVmYXVsdHMgdG8gdHJ1ZS5cbiAgICogQHBhcmFtIHNoaWZ0ICAgICAgICAgU2hpZnQgcG9pbnQgdG8gdGhlIHN0YXJ0IG9mIHNlcmllcy4gVGhpcyBkZWZhdWx0cyB0byBmYWxzZS5cbiAgICovXG4gIGFkZFBvaW50KHBvaW50OiBQb2ludCwgc2VyaWVJbmRleDogbnVtYmVyID0gMCwgcmVkcmF3OiBib29sZWFuID0gdHJ1ZSwgc2hpZnQ6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xuICAgIHRoaXMucmVmJC5zdWJzY3JpYmUoY2hhcnQgPT4ge1xuICAgICAgaWYgKGNoYXJ0LnNlcmllcy5sZW5ndGggPiBzZXJpZUluZGV4KSB7XG4gICAgICAgIGNoYXJ0LnNlcmllc1tzZXJpZUluZGV4XS5hZGRQb2ludChwb2ludCwgcmVkcmF3LCBzaGlmdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIFNlcmllc1xuICAgKiBAcGFyYW0gc2VyaWVzICAgICAgICBTZXJpZXMgQ29uZmlndXJhdGlvblxuICAgKiBAcGFyYW0gcmVkcmF3ICAgICAgICBGbGFnIHdoZXRoZXIgb3Igbm90IHRvIHJlZHJhdyBzZXJpZXMuIFRoaXMgZGVmYXVsdHMgdG8gdHJ1ZS5cbiAgICogQHBhcmFtIGFuaW1hdGlvbiAgICAgV2hldGhlciB0byBhcHBseSBhbmltYXRpb24sIGFuZCBvcHRpb25hbGx5IGFuaW1hdGlvbiBjb25maWd1cmF0aW9uLiBUaGlzIGRlZmF1bHRzIHRvIGZhbHNlLlxuICAgKi9cbiAgYWRkU2VyaWVzKHNlcmllczogSGlnaGNoYXJ0cy5TZXJpZXNPcHRpb25zVHlwZSwgcmVkcmF3ID0gdHJ1ZSwgYW5pbWF0aW9uOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5yZWYkLnN1YnNjcmliZShjaGFydCA9PiB7XG4gICAgICBjaGFydC5hZGRTZXJpZXMoc2VyaWVzLCByZWRyYXcsIGFuaW1hdGlvbik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIFBvaW50XG4gICAqIEBwYXJhbSBwb2ludEluZGV4ICAgIEluZGV4IG9mIFBvaW50XG4gICAqIEBwYXJhbSBzZXJpZUluZGV4ICAgIFNwZWNpZmllZCBJbmRleCBvZiBTZXJpZXMuIERlZmF1bHRzIHRvIDAuXG4gICAqL1xuICByZW1vdmVQb2ludChwb2ludEluZGV4OiBudW1iZXIsIHNlcmllSW5kZXggPSAwKTogdm9pZCB7XG4gICAgdGhpcy5yZWYkLnN1YnNjcmliZShjaGFydCA9PiB7XG4gICAgICBpZiAoY2hhcnQuc2VyaWVzLmxlbmd0aCA+IHNlcmllSW5kZXggJiYgY2hhcnQuc2VyaWVzW3NlcmllSW5kZXhdLmRhdGEubGVuZ3RoID4gcG9pbnRJbmRleCkge1xuICAgICAgICBjaGFydC5zZXJpZXNbc2VyaWVJbmRleF0ucmVtb3ZlUG9pbnQocG9pbnRJbmRleCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIFNlcmllc1xuICAgKiBAcGFyYW0gc2VyaWVzSW5kZXggICAgSW5kZXggcG9zaXRpb24gb2Ygc2VyaWVzIHRvIHJlbW92ZS5cbiAgICovXG4gIHJlbW92ZVNlcmllcyhzZXJpZXNJbmRleDogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5yZWYkLnN1YnNjcmliZShjaGFydCA9PiB7XG4gICAgICBpZiAoY2hhcnQuc2VyaWVzLmxlbmd0aCA+IHNlcmllc0luZGV4KSB7XG4gICAgICAgIGNoYXJ0LnNlcmllc1tzZXJpZXNJbmRleF0ucmVtb3ZlKHRydWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaW5pdChlbDogRWxlbWVudFJlZik6IHZvaWQge1xuICAgIGlmICghdGhpcy5yZWYpIHtcbiAgICAgIEhpZ2hjaGFydHMuY2hhcnQoZWwubmF0aXZlRWxlbWVudCwgdGhpcy5vcHRpb25zLCBjaGFydCA9PiB7XG4gICAgICAgIGlmICghdGhpcy5yZWYpIHsgLy8gVE9ETzogd29ya2Fyb3VuZCBmb3IgZG91YmxlZCBjYWxsYmFja3Mgb24gZXhwb3J0aW5nIGNoYXJ0czogaXNzdWUgIzIzOFxuICAgICAgICAgIHRoaXMucmVmU3ViamVjdC5uZXh0KGNoYXJ0KTtcbiAgICAgICAgICB0aGlzLnJlZiA9IGNoYXJ0O1xuICAgICAgICAgIHRoaXMucmVmU3ViamVjdC5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnJlZikge1xuICAgICAgdGhpcy5vcHRpb25zID0gdGhpcy5yZWYub3B0aW9ucztcbiAgICAgIHRoaXMucmVmLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMucmVmID0gdW5kZWZpbmVkO1xuXG4gICAgICAvLyBuZXcgaW5pdCBzdWJqZWN0XG4gICAgICB0aGlzLnJlZlN1YmplY3QgPSBuZXcgQXN5bmNTdWJqZWN0KCk7XG4gICAgICB0aGlzLnJlZiQgPSB0aGlzLnJlZlN1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgfVxuICB9XG59XG4iXX0=